# .github/workflows/manual-deployment.yml
name: Manual Deployment

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to deploy (required)'
        required: true
        type: string
      deploy_remotes:
        description: 'Deploy remote applications'
        required: true
        default: true
        type: boolean
      deploy_server:
        description: 'Deploy server applications'
        required: true
        default: true
        type: boolean

permissions:
  contents: read
  actions: read
  pull-requests: read

env:
  NODE_VERSION: '20'
  NX_NO_CLOUD: true
  MF_MANIFEST_PATH: 'client-shell'
  MF_MANIFEST_FILE_NAME: 'mf-manifest.prod.json'
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY_PREFIX: ${{ secrets.ECR_REPOSITORY_PREFIX }}
  CDN_BUCKET: ${{ secrets.CDN_BUCKET }}
  CDN_DISTRIBUTION_ID: ${{ secrets.CDN_DISTRIBUTION_ID }}

jobs:
  load-detection-results:
    runs-on: ubuntu-latest
    outputs:
      affected-apps: ${{ steps.load.outputs.affected_apps }}
      has-server-changes: ${{ steps.load.outputs.has_server_changes }}
      affected-remotes: ${{ steps.load.outputs.affected_remotes }}
      client_shell_affected: ${{ steps.load.outputs.client_shell_affected }}
      be_vendure_affected: ${{ steps.load.outputs.be_vendure_affected }}
    steps:
      - name: Download artifact via API
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Searching for artifact from PR #${{ github.event.inputs.pr_number }}..."

          # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤
          ARTIFACTS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts[] | select(.name == "detection-results-pr-${{ github.event.inputs.pr_number }}") | {id, name, expired, created_at}')

          if [ -z "$ARTIFACTS" ]; then
            echo "‚ùå No artifact found for PR #${{ github.event.inputs.pr_number }}"
            echo "Please ensure the PR detection workflow has completed successfully."
            exit 1
          fi

          echo "Found artifact:"
          echo "$ARTIFACTS"

          # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞
          ARTIFACT_ID=$(echo "$ARTIFACTS" | jq -r '.id' | head -n1)

          # –°–∫–∞—á–∏–≤–∞–µ–º –∞—Ä—Ç–µ—Ñ–∞–∫—Ç
          echo "Downloading artifact ID: $ARTIFACT_ID"
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip \
            > artifact.zip

          # –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º
          unzip artifact.zip
          ls -la

      - name: Load and display detection results
        id: load
        run: |
          if [ -f detection-results.json ]; then
            echo "üìã Deployment Summary for PR #${{ github.event.inputs.pr_number }}:"
            echo "================================"
            cat detection-results.json | jq -r '
              "PR Title: \(.pr_title)",
              "PR URL: \(.pr_url)",
              "Detection Time: \(.timestamp)",
              "",
              "Affected Applications:",
              (.affected_apps | map("  - " + .) | join("\n")),
              "",
              "Remote Applications: \(.affected_remotes | length)",
              "Server Changes: \(.has_server_changes)"
            '
            echo "================================"

            # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ outputs
            echo "affected_apps=$(jq -c '.affected_apps' detection-results.json)" >> $GITHUB_OUTPUT
            echo "affected_remotes=$(jq -c '.affected_remotes' detection-results.json)" >> $GITHUB_OUTPUT
            echo "has_server_changes=$(jq -r '.has_server_changes' detection-results.json)" >> $GITHUB_OUTPUT
            echo "client_shell_affected=$(jq -r '.client_shell_affected' detection-results.json)" >> $GITHUB_OUTPUT
            echo "be_vendure_affected=$(jq -r '.be_vendure_affected' detection-results.json)" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No detection results found in artifact!"
            exit 1
          fi

  build-and-deploy-remotes:
    needs: load-detection-results
    if: github.event.inputs.deploy_remotes == 'true' && needs.load-detection-results.outputs.affected-remotes != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.load-detection-results.outputs.affected-remotes) }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build in Docker
        run: |
          docker run --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            node:20-alpine \
            sh -c "npm ci --legacy-peer-deps && npx nx run ${{ matrix.app }}:server:production"

      - name: Generate version
        id: version
        run: |
          VERSION="${{ github.sha }}-$(date +%Y%m%d%H%M%S)"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Upload to S3 CDN
        run: |
          APP_NAME="${{ matrix.app }}"
          VERSION="${{ steps.version.outputs.version }}"
          BUILD_PATH="dist/apps/clients/$APP_NAME"

          # Upload versioned build
          aws s3 sync $BUILD_PATH $CDN_BUCKET/$APP_NAME/$VERSION/ \
            --delete \
            --cache-control "public, max-age=31536000"

          # Upload as latest
          aws s3 sync $BUILD_PATH $CDN_BUCKET/$APP_NAME/latest/ \
            --delete \
            --cache-control "public, max-age=300"

      - name: Update manifest
        run: |
          APP_NAME="${{ matrix.app }}"
          VERSION="${{ steps.version.outputs.version }}"

          # Download current manifest
          aws s3 cp $CDN_BUCKET/$MF_MANIFEST_PATH/$MF_MANIFEST_FILE_NAME ./$MF_MANIFEST_FILE_NAME || echo '{}' > ./$MF_MANIFEST_FILE_NAME

          # Update manifest with new version
          jq --arg app "$APP_NAME" \
             --arg server "https://cdn.ewandr.com/$APP_NAME/$VERSION/server/remoteEntry.js" \
             --arg browser "https://cdn.ewandr.com/$APP_NAME/$VERSION/browser/mf-manifest.json" \
             '.[$app] = {server: $server, browser: $browser}' \
             ./$MF_MANIFEST_FILE_NAME > ./mf-manifest-updated.json

          # Upload updated manifest
          aws s3 cp ./mf-manifest-updated.json $CDN_BUCKET/$MF_MANIFEST_PATH/$MF_MANIFEST_FILE_NAME \
            --cache-control "public, max-age=60"

      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation \
            --distribution-id $CDN_DISTRIBUTION_ID \
            --paths "/$MF_MANIFEST_PATH/$MF_MANIFEST_FILE_NAME" "/${{ matrix.app }}/latest/*"

  build-and-push-server:
    needs: load-detection-results
    if: github.event.inputs.deploy_server == 'true' && needs.load-detection-results.outputs.has-server-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: [ 'client-shell', 'be-vendure' ]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Check if app was affected
        id: check-affected
        run: |
          if echo '${{ needs.load-detection-results.outputs.affected-apps }}' | jq -r '.[]' | grep -q "^${{ matrix.app }}$"; then
            echo "affected=true" >> $GITHUB_OUTPUT
          else
            echo "affected=false" >> $GITHUB_OUTPUT
          fi

      - name: Build be-vendure application
        if: matrix.app == 'be-vendure' && needs.load-detection-results.outputs.be_vendure_affected == 'true'
        run: |
          echo ">>> Running NX build for be-vendure‚Ä¶"
          npx nx run be-vendure:build:production

          echo ">>> Listing all dist/apps directories:"
          ls -R dist/apps

          echo ">>> Contents of the be-vendure build folder:"
          ls -l dist/apps/backends/be-vendure || echo "Folder not found: dist/apps/backends/be-vendure"

      - name: Build client-shell application
        if: matrix.app == 'client-shell' && needs.load-detection-results.outputs.client_shell_affected == 'true'
        run: npx nx run client-shell:build:production --excludeTaskDependencies && npx nx run client-shell:server:production --excludeTaskDependencies

      - name: Configure AWS credentials
        if: steps.check-affected.outputs.affected == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: steps.check-affected.outputs.affected == 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image with unique tag
        if: steps.check-affected.outputs.affected == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ç–µ–≥ —Å PR –Ω–æ–º–µ—Ä–æ–º –∏ timestamp
          IMAGE_TAG: pr-${{ github.event.inputs.pr_number }}-${{ github.run_number }}-${{ github.sha }}
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REPOSITORY_PREFIX: ${{ env.ECR_REPOSITORY_PREFIX }}
        run: |
          echo "Building with unique tag: $IMAGE_TAG"
          echo "ECR_REGISTRY: $ECR_REGISTRY"
          echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
          echo "AWS_REGION: $AWS_REGION"

          # –í–ê–ñ–ù–û: –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º IMAGE_TAG —á—Ç–æ–±—ã —Å–∫—Ä–∏–ø—Ç –µ–≥–æ —É–≤–∏–¥–µ–ª
          export IMAGE_TAG=$IMAGE_TAG

          # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫—Ä–∏–ø—Ç —Å–±–æ—Ä–∫–∏
          SCRIPT_NAME="CI_CD/ecr-${{ matrix.app }}.sh"
          if [ -f "./$SCRIPT_NAME" ]; then
            echo "Running $SCRIPT_NAME"
            chmod +x ./$SCRIPT_NAME
            ./$SCRIPT_NAME
          else
            echo "Script $SCRIPT_NAME not found!"
            exit 1
          fi

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ–±—Ä–∞–∑ —Å–æ–∑–¥–∞–Ω –≤ ECR
          echo "üîç Verifying image in ECR..."
          if aws ecr describe-images \
            --repository-name "ewandr/${{ matrix.app }}" \
            --image-ids imageTag=$IMAGE_TAG \
            --region $AWS_REGION 2>/dev/null; then
            echo "‚úÖ Image successfully pushed to ECR!"
          else
            echo "‚ùå ERROR: Image not found in ECR after push!"
            exit 1
          fi

      - name: Clean up old ECR images
        if: steps.check-affected.outputs.affected == 'true'
        env:
          REPO_NAME: ewandr/${{ matrix.app }}
        run: |
          echo "üßπ Cleaning up old ECR images for $REPO_NAME..."

          # –°–ø–∏—Å–æ–∫ –æ–±—Ä–∞–∑–æ–≤, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç —Å–∞–º—ã—Ö —Å—Ç–∞—Ä—ã—Ö –∫ —Å–∞–º—ã–º –Ω–æ–≤—ã–º
          IMAGES=$(aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --query 'sort_by(imageDetails,&imagePushedAt)[*].[imageDigest, imageTags[0], imagePushedAt]' \
            --output text)

          IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
          echo "Found $IMAGE_COUNT images"

          if [ "$IMAGE_COUNT" -gt 5 ]; then
            # –°—á–∏—Ç–∞–µ–º, —Å–∫–æ–ª—å–∫–æ –Ω–∞–¥–æ —É–¥–∞–ª–∏—Ç—å, —á—Ç–æ–±—ã –æ—Å—Ç–∞–ª–æ—Å—å —Ä–æ–≤–Ω–æ 5
            DELETE_COUNT=$((IMAGE_COUNT - 5))
            echo "Will delete $DELETE_COUNT old images"

            # –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–µ DELETE_COUNT —Å—Ç—Ä–æ–∫ ‚Äî —ç—Ç–æ —Å–∞–º—ã–µ —Å—Ç–∞—Ä—ã–µ –æ–±—Ä–∞–∑—ã
            IMAGES_TO_DELETE=$(echo "$IMAGES" | head -n "$DELETE_COUNT")

            echo "$IMAGES_TO_DELETE" | while read -r digest tag pushed_at; do
              [ -n "$digest" ] || continue
              echo "Deleting image with digest: $digest (tag: $tag, pushed: $pushed_at)"
              aws ecr batch-delete-image \
                --repository-name "$REPO_NAME" \
                --image-ids imageDigest="$digest" || true
            done
          else
            echo "No cleanup needed, only $IMAGE_COUNT images exist"
          fi

  update-server-configuration:
    needs: [ load-detection-results, build-and-push-server ]
    if: |
      github.event.inputs.deploy_server == 'true' &&
      needs.build-and-push-server.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/lightsail_key
          chmod 600 ~/.ssh/lightsail_key
          ssh-keyscan -H ${{ secrets.LIGHTSAIL_HOST }} >> ~/.ssh/known_hosts

      - name: Update .env.production with unique tags
        env:
          SSH_KEY: ~/.ssh/lightsail_key
          REMOTE_USER: ${{ secrets.LIGHTSAIL_USER }}
          REMOTE_HOST: ${{ secrets.LIGHTSAIL_HOST }}
        run: |
          set -eo pipefail
          echo "üìù Updating server configuration with unique image tags‚Ä¶"

          # 1) –°–∫–∞—á–∏–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π .env.production
          ssh -i "$SSH_KEY" "$REMOTE_USER@$REMOTE_HOST" \
            "cat ~/ewandr/.env.production" > old_env_prod 2>/dev/null || true

          # 2) –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
          OLD_CLIENT_SHELL_TAG="latest"
          OLD_BE_VENDURE_TAG="latest"

          # 3) –ï—Å–ª–∏ —Å–∫–∞—á–∞–ª–∏ –Ω–µ–ø—É—Å—Ç–æ–π —Ñ–∞–π–ª ‚Äî –ø–∞—Ä—Å–∏–º –∏–∑ –Ω–µ–≥–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
          if [ -s old_env_prod ]; then
            OLD_CLIENT_SHELL_TAG=$(grep -E '^CLIENT_SHELL_TAG=' old_env_prod | cut -d= -f2- || echo "latest")
            OLD_BE_VENDURE_TAG=$(grep -E '^BE_VENDURE_TAG=' old_env_prod | cut -d= -f2- || echo "latest")
            echo "Existing tags: CLIENT_SHELL_TAG=$OLD_CLIENT_SHELL_TAG, BE_VENDURE_TAG=$OLD_BE_VENDURE_TAG"
          else
            echo "No remote .env.production found, defaulting tags to 'latest'"
          fi

          # 4) –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π tag - –¢–ê–ö–û–ô –ñ–ï –ö–ê–ö –í build-and-push-server
          UNIQUE_TAG="pr-${{ github.event.inputs.pr_number }}-${{ github.run_number }}-${{ github.sha }}"

          # 5) –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–µ–≥–∏
          CLIENT_SHELL_TAG="$OLD_CLIENT_SHELL_TAG"
          BE_VENDURE_TAG="$OLD_BE_VENDURE_TAG"

          # 6) –û–±–Ω–æ–≤–ª—è–µ–º –¢–û–õ–¨–ö–û –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
          if [ "${{ needs.load-detection-results.outputs.client_shell_affected }}" = "true" ]; then
            CLIENT_SHELL_TAG="$UNIQUE_TAG"
            echo "‚úÖ Updating CLIENT_SHELL_TAG to $UNIQUE_TAG"
          else
            echo "‚è≠Ô∏è Keeping CLIENT_SHELL_TAG as $OLD_CLIENT_SHELL_TAG (not affected)"
          fi

          if [ "${{ needs.load-detection-results.outputs.be_vendure_affected }}" = "true" ]; then
            BE_VENDURE_TAG="$UNIQUE_TAG"
            echo "‚úÖ Updating BE_VENDURE_TAG to $UNIQUE_TAG"
          else
            echo "‚è≠Ô∏è Keeping BE_VENDURE_TAG as $OLD_BE_VENDURE_TAG (not affected)"
          fi

          echo "Final tags: CLIENT_SHELL_TAG=$CLIENT_SHELL_TAG, BE_VENDURE_TAG=$BE_VENDURE_TAG"

          # 7) –°–æ–±–∏—Ä–∞–µ–º –Ω–æ–≤—ã–π .env.production
          cat > .env.production <<EOF
          # Auto-generated by GitHub Actions
          # PR: #${{ github.event.inputs.pr_number }}
          # Run: #${{ github.run_number }}
          # Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ECR_REGISTRY=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          ECR_REPOSITORY_PREFIX=${{ env.ECR_REPOSITORY_PREFIX }}

          CLIENT_SHELL_TAG=${CLIENT_SHELL_TAG}
          BE_VENDURE_TAG=${BE_VENDURE_TAG}
          EOF

          # 8) –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —á—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
          echo ""
          echo "üìã .env.production content:"
          cat .env.production
          echo ""

          # 9) –ö–æ–ø–∏—Ä—É–µ–º –∏ –∞—Ç–æ–º–∞—Ä–Ω–æ –º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
          scp -i "$SSH_KEY" .env.production "$REMOTE_USER@$REMOTE_HOST:~/ewandr/.env.production.new"
          ssh -i "$SSH_KEY" "$REMOTE_USER@$REMOTE_HOST" <<'ENDSSH'
          set -eo pipefail
          cd ~/ewandr
          cp .env.production .env.production.backup-$(date +%Y%m%d-%H%M%S) || true
          mv .env.production.new .env.production
          echo "‚úÖ .env.production successfully updated"
          cat .env.production
          ENDSSH
      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/lightsail_key ./.env.production


  pull-latest-images:
    needs: [ load-detection-results, build-and-push-server, update-server-configuration ]
    if: |
      github.event.inputs.deploy_server == 'true' &&
      needs.build-and-push-server.result == 'success' &&
      needs.update-server-configuration.result == 'success' &&
      (needs.load-detection-results.outputs.client_shell_affected == 'true' ||
       needs.load-detection-results.outputs.be_vendure_affected == 'true')
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/lightsail_key
          chmod 600 ~/.ssh/lightsail_key
          ssh-keyscan -H ${{ secrets.LIGHTSAIL_HOST }} >> ~/.ssh/known_hosts

      - name: Pull latest images on server
        run: |
          echo "üîÑ Pulling latest images on Lightsail server..."

          # SSH –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥
          ssh -i ~/.ssh/lightsail_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} << 'ENDSSH'
            set -e
            cd ~/ewandr

            echo "üìã Current .env.production:"
            cat .env.production

            echo "üîê Logging in to AWS ECR..."
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
              docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

            SERVICES_TO_PULL=""

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ —Å–µ—Ä–≤–∏—Å—ã –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
            if [[ "${{ needs.load-detection-results.outputs.client_shell_affected }}" == "true" ]]; then
              SERVICES_TO_PULL="client-shell"
              echo "üì¶ Will pull client-shell image"
            fi

            if [[ "${{ needs.load-detection-results.outputs.be_vendure_affected }}" == "true" ]]; then
              if [[ -n "$SERVICES_TO_PULL" ]]; then
                SERVICES_TO_PULL="$SERVICES_TO_PULL be-vendure"
              else
                SERVICES_TO_PULL="be-vendure"
              fi
              echo "üì¶ Will pull be-vendure image"
            fi

            echo "üîÑ Pulling images for: $SERVICES_TO_PULL"
            docker-compose --env-file .env.production -f docker-compose.prod.yml pull $SERVICES_TO_PULL

            echo "‚úÖ Images pulled successfully!"

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ–±—Ä–∞–∑—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å–∫–∞—á–∞–ª–∏—Å—å
            echo "üìä Checking downloaded images:"
            docker images | grep -E "(client-shell|be-vendure)" | head -10
          ENDSSH

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/lightsail_key



  cleanup-server-docker:
    needs: [load-detection-results, update-server-configuration, pull-latest-images]
    if: always() && needs.pull-latest-images.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/lightsail_key
          chmod 600 ~/.ssh/lightsail_key
          ssh-keyscan -H ${{ secrets.LIGHTSAIL_HOST }} >> ~/.ssh/known_hosts

      - name: Cleanup old Docker images on server
        run: |
          echo "üßπ Cleaning up Docker images on Lightsail server..."

          ssh -i ~/.ssh/lightsail_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} << 'ENDSSH'
            set -e
            cd ~/ewandr

            echo "üìä Docker disk usage before cleanup:"
            docker system df

            # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –æ–±—Ä–∞–∑–æ–≤, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ 5 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö
            cleanup_images() {
              local app_name=$1
              echo "Cleaning up images for $app_name..."

              # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ–±—Ä–∞–∑—ã –¥–ª—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –¥–∞—Ç–µ —Å–æ–∑–¥–∞–Ω–∏—è
              IMAGES=$(docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}\t{{.ID}}" |
                       grep "$app_name" |
                       grep -v "<none>" |
                       sort -k2 -r)

              # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
              IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
              echo "Found $IMAGE_COUNT images for $app_name"

              if [ $IMAGE_COUNT -gt 5 ]; then
                # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ 5 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö
                echo "$IMAGES" | tail -n +6 | awk '{print $3}' | while read IMAGE_ID; do
                  echo "Removing old image: $IMAGE_ID"
                  docker rmi -f $IMAGE_ID || true
                done
              fi
            }

            # –û—á–∏—â–∞–µ–º –æ–±—Ä–∞–∑—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
            cleanup_images "client-shell"
            cleanup_images "be-vendure"

            # –£–¥–∞–ª—è–µ–º –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã
            echo "üóëÔ∏è Removing dangling images..."
            docker image prune -f

            # –£–¥–∞–ª—è–µ–º –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ build cache
            echo "üóëÔ∏è Cleaning build cache..."
            docker builder prune -f --keep-storage=2GB

            echo "üìä Docker disk usage after cleanup:"
            docker system df

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            echo "üíæ Disk usage: $DISK_USAGE%"

            if [ $DISK_USAGE -gt 80 ]; then
              echo "‚ö†Ô∏è WARNING: Disk usage is still high ($DISK_USAGE%)!"
              echo "Consider running more aggressive cleanup manually"
            fi
          ENDSSH

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/lightsail_key

  restart-lightsail-services:
    needs: [ load-detection-results, build-and-push-server, build-and-deploy-remotes, update-server-configuration, pull-latest-images, cleanup-server-docker ]
    if: |
      always() &&
      (needs.build-and-push-server.result == 'success' ||
       needs.build-and-push-server.result == 'skipped') &&
      (needs.build-and-deploy-remotes.result == 'success' ||
       needs.build-and-deploy-remotes.result == 'skipped') &&
      (needs.pull-latest-images.result == 'success' ||
       needs.pull-latest-images.result == 'skipped') &&
      (needs.load-detection-results.outputs.has-server-changes == 'true' ||
       needs.load-detection-results.outputs.affected-remotes != '[]')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ['client-shell', 'be-vendure']
    steps:
      - name: Check if app needs restart
        id: check-restart
        run: |
          NEEDS_RESTART="false"

          # be-vendure –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω —Å–∞–º –±—ã–ª –∏–∑–º–µ–Ω–µ–Ω –ò deploy_server == true
          if [[ "${{ matrix.app }}" == "be-vendure" &&
                "${{ needs.load-detection-results.outputs.be_vendure_affected }}" == "true" &&
                "${{ github.event.inputs.deploy_server }}" == "true" ]]; then
            NEEDS_RESTART="true"
            echo "üîÑ be-vendure was affected and server deployment enabled, needs restart"
          fi

          # client-shell –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –µ—Å–ª–∏:
          # 1. –û–Ω —Å–∞–º –±—ã–ª –∏–∑–º–µ–Ω–µ–Ω –ò deploy_server == true
          # 2. –õ—é–±—ã–µ remote –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã –ò deploy_remotes == true
          if [[ "${{ matrix.app }}" == "client-shell" ]]; then
            if [[ "${{ needs.load-detection-results.outputs.client_shell_affected }}" == "true" &&
                  "${{ github.event.inputs.deploy_server }}" == "true" ]]; then
              NEEDS_RESTART="true"
              echo "üîÑ client-shell was directly affected and server deployment enabled, needs restart"
            elif [[ "${{ needs.load-detection-results.outputs.affected-remotes }}" != "[]" &&
                    "${{ github.event.inputs.deploy_remotes }}" == "true" ]]; then
              NEEDS_RESTART="true"
              echo "üîÑ Remote apps were updated and remote deployment enabled, client-shell (host) needs restart to pick up new remotes"
            fi
          fi

          echo "needs_restart=$NEEDS_RESTART" >> $GITHUB_OUTPUT
          echo "Decision for ${{ matrix.app }}: $NEEDS_RESTART"

      - name: Setup SSH key
        if: steps.check-restart.outputs.needs_restart == 'true'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/lightsail_key
          chmod 600 ~/.ssh/lightsail_key

          # –î–æ–±–∞–≤–ª—è–µ–º —Ö–æ—Å—Ç –≤ known_hosts —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
          ssh-keyscan -H ${{ secrets.LIGHTSAIL_HOST }} >> ~/.ssh/known_hosts

      - name: Restart service with new image
        if: steps.check-restart.outputs.needs_restart == 'true'
        run: |
          echo "üîÑ Restarting ${{ matrix.app }} on Lightsail..."

          # SSH –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥
          ssh -i ~/.ssh/lightsail_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} << 'ENDSSH'
            set -e
            cd ~/ewandr

            echo "üìã Using .env.production:"
            cat .env.production | grep "_TAG="

            # –í–ê–ñ–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º --no-deps —á—Ç–æ–±—ã –Ω–µ —Ç—Ä–æ–≥–∞—Ç—å –∑–∞–≤–∏—Å–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
            echo "üõë Stopping ${{ matrix.app }}..."
            docker-compose --env-file .env.production -f docker-compose.prod.yml stop ${{ matrix.app }}

            echo "üóëÔ∏è Removing old container..."
            docker-compose --env-file .env.production -f docker-compose.prod.yml rm -f ${{ matrix.app }}

            echo "üöÄ Starting ${{ matrix.app }} with new image..."
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º --no-deps —á—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –¢–û–õ–¨–ö–û —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å
            docker-compose --env-file .env.production -f docker-compose.prod.yml up -d --no-deps ${{ matrix.app }}

            echo "‚è≥ Waiting for container to be ready..."
            sleep 10

            echo "üìä Checking container status..."
            docker-compose --env-file .env.production -f docker-compose.prod.yml ps ${{ matrix.app }}

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω
            if docker-compose --env-file .env.production -f docker-compose.prod.yml ps ${{ matrix.app }} | grep -q "Up"; then
              echo "‚úÖ ${{ matrix.app }} is running!"

              # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–∫–æ–π –æ–±—Ä–∞–∑ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
              CONTAINER_ID=$(docker-compose --env-file .env.production -f docker-compose.prod.yml ps -q ${{ matrix.app }})
              echo "üì¶ Running image:"
              docker inspect --format='{{.Config.Image}}' "$CONTAINER_ID"

              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫ –∑–∞–ø—É—Å–∫–∞
              echo "üìú Recent logs:"
              docker-compose --env-file .env.production -f docker-compose.prod.yml logs --tail=20 ${{ matrix.app }}
            else
              echo "‚ùå ${{ matrix.app }} is not running properly!"
              docker-compose --env-file .env.production -f docker-compose.prod.yml logs --tail=100 ${{ matrix.app }}
              exit 1
            fi
          ENDSSH
      - name: Health check
        if: steps.check-restart.outputs.needs_restart == 'true'
        run: |
          echo "‚è≥ Waiting for service to be fully ready..."
          sleep 30

          # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –ø—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–≤–∏—Å–∞ —á–µ—Ä–µ–∑ HTTP
          if [[ "${{ matrix.app }}" == "client-shell" ]]; then
            if [[ -n "${{ secrets.PRODUCTION_DOMAIN }}" ]]; then
              echo "üîç Checking client-shell health..."
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.PRODUCTION_DOMAIN }} || echo "000")
              if [[ "$RESPONSE" == "200" ]]; then
                echo "‚úÖ client-shell is healthy (HTTP $RESPONSE)"
              else
                echo "‚ö†Ô∏è client-shell health check returned HTTP $RESPONSE"
              fi
            fi
          elif [[ "${{ matrix.app }}" == "be-vendure" ]]; then
            if [[ -n "${{ secrets.PRODUCTION_DOMAIN }}" ]]; then
              echo "üîç Checking be-vendure health..."
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.PRODUCTION_DOMAIN }}/api/health || echo "000")
              if [[ "$RESPONSE" == "200" ]]; then
                echo "‚úÖ be-vendure is healthy (HTTP $RESPONSE)"
              else
                echo "‚ö†Ô∏è be-vendure health check returned HTTP $RESPONSE"
              fi
            fi
          fi

          # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ SSH
          echo "üîç Final container check..."
          ssh -i ~/.ssh/lightsail_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} \
            "cd ~/ewandr && docker-compose -f docker-compose.prod.yml ps ${{ matrix.app }}"

      - name: Cleanup SSH
        if: always() && steps.check-restart.outputs.needs_restart == 'true'
        run: |
          rm -f ~/.ssh/lightsail_key

  deployment-summary:
    needs: [ load-detection-results, build-and-deploy-remotes, build-and-push-server, restart-lightsail-services ]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Create deployment summary
        run: |
          echo "# üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR Number:** #${{ github.event.inputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "**Commit SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Remote Applications Section
          if [[ "${{ github.event.inputs.deploy_remotes }}" == "true" ]]; then
            echo "## üì¶ Remote Applications" >> $GITHUB_STEP_SUMMARY

            REMOTE_APPS='${{ needs.load-detection-results.outputs.affected-remotes }}'
            if [[ "$REMOTE_APPS" != "[]" && "$REMOTE_APPS" != "" ]]; then
              echo "**Status:** ${{ needs.build-and-deploy-remotes.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
              echo "**Updated Apps:**" >> $GITHUB_STEP_SUMMARY
              echo "$REMOTE_APPS" | jq -r '.[]' | while read app; do
                echo "- ‚úÖ $app" >> $GITHUB_STEP_SUMMARY
              done
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "‚ÑπÔ∏è *Note: client-shell will be restarted to load updated remote applications*" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Status:** No remote applications to deploy" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Server Applications Section
          if [[ "${{ github.event.inputs.deploy_server }}" == "true" ]]; then
            echo "## üñ•Ô∏è Server Applications" >> $GITHUB_STEP_SUMMARY
            echo "**Build Status:** ${{ needs.build-and-push-server.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "**Restart Status:** ${{ needs.restart-lightsail-services.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # –î–µ—Ç–∞–ª–∏ –ø–æ –∫–∞–∂–¥–æ–º—É —Å–µ—Ä–≤–µ—Ä–Ω–æ–º—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é
            if [[ "${{ needs.load-detection-results.outputs.client_shell_affected }}" == "true" ]]; then
              echo "### client-shell" >> $GITHUB_STEP_SUMMARY
              echo "- üîÑ Direct changes detected" >> $GITHUB_STEP_SUMMARY
              echo "- üê≥ Docker image updated" >> $GITHUB_STEP_SUMMARY
              echo "- ‚ôªÔ∏è Service restarted" >> $GITHUB_STEP_SUMMARY
            elif [[ "${{ needs.load-detection-results.outputs.affected-remotes }}" != "[]" ]]; then
              echo "### client-shell" >> $GITHUB_STEP_SUMMARY
              echo "- üîó Restarted due to remote apps updates" >> $GITHUB_STEP_SUMMARY
              echo "- ‚ôªÔ∏è Service restarted to load new remotes" >> $GITHUB_STEP_SUMMARY
            fi

            if [[ "${{ needs.load-detection-results.outputs.be_vendure_affected }}" == "true" ]]; then
              echo "### be-vendure" >> $GITHUB_STEP_SUMMARY
              echo "- üîÑ Direct changes detected" >> $GITHUB_STEP_SUMMARY
              echo "- üê≥ Docker image updated" >> $GITHUB_STEP_SUMMARY
              echo "- ‚ôªÔ∏è Service restarted" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Summary Statistics
          echo "## üìä Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # –ü–æ–¥—Å—á–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
          TOTAL_APPS=0
          REMOTE_COUNT=0
          SERVER_COUNT=0

          REMOTE_APPS='${{ needs.load-detection-results.outputs.affected-remotes }}'
          if [[ "$REMOTE_APPS" != "[]" && "$REMOTE_APPS" != "" ]]; then
            REMOTE_COUNT=$(echo "$REMOTE_APPS" | jq 'length')
            TOTAL_APPS=$((TOTAL_APPS + REMOTE_COUNT))
          fi

          if [[ "${{ needs.load-detection-results.outputs.client_shell_affected }}" == "true" ]]; then
            SERVER_COUNT=$((SERVER_COUNT + 1))
            TOTAL_APPS=$((TOTAL_APPS + 1))
          fi

          if [[ "${{ needs.load-detection-results.outputs.be_vendure_affected }}" == "true" ]]; then
            SERVER_COUNT=$((SERVER_COUNT + 1))
            TOTAL_APPS=$((TOTAL_APPS + 1))
          fi

          echo "- **Total Applications Updated:** $TOTAL_APPS" >> $GITHUB_STEP_SUMMARY
          echo "- **Remote Applications:** $REMOTE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Server Applications:** $SERVER_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Final Status
          echo "## üéØ Final Status" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.build-and-deploy-remotes.result }}" == "success" || "${{ needs.build-and-deploy-remotes.result }}" == "skipped" ]] && \
             [[ "${{ needs.build-and-push-server.result }}" == "success" || "${{ needs.build-and-push-server.result }}" == "skipped" ]] && \
             [[ "${{ needs.restart-lightsail-services.result }}" == "success" || "${{ needs.restart-lightsail-services.result }}" == "skipped" ]]; then
            echo "‚úÖ **Deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed or partially completed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi
