# .github/workflows/pr-detection.yml
name: PR Change Detection

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  NODE_VERSION: '20'
  NX_NO_CLOUD: true
  NX_PREFER_TS_NODE: true

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        timeout-minutes: 5
        run: npm ci --legacy-peer-deps --prefer-offline

      - name: Validate configuration files
        timeout-minutes: 2
        run: |
          # Validate config files to prevent NX graph errors
          for file in $(find . -name "playwright.config.ts" -o -name "webpack.config.ts" 2>/dev/null); do
            if ! npx tsc --noEmit --skipLibCheck "$file" 2>/dev/null; then
              echo "::warning::Syntax error in $file - creating backup"
              mv "$file" "$file.original"
              echo "export default {};" > "$file"
            fi
          done

      - name: Detect affected apps
        id: detect
        timeout-minutes: 5
        shell: bash
        run: |
          set -eo pipefail
          echo "Node: $(node -v) | npm: $(npm -v)"
          npx nx --version || true

          # 1) Find BASE/HEAD commits
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            echo "Fetching base branch: $BASE_REF"

            if ! git fetch --no-tags --prune --depth=1 origin "+refs/heads/${BASE_REF}:refs/remotes/origin/${BASE_REF}" 2>/dev/null; then
              echo "⚠️ Shallow fetch failed, attempting unshallow..."
              if ! git fetch --no-tags --prune --unshallow 2>/dev/null; then
                echo "❌ Failed to fetch git history. Using current HEAD~1 as fallback."
                BASE="$(git rev-parse HEAD~1 2>/dev/null || echo "${{ github.event.pull_request.base.sha }}")"
              else
                BASE="$(git merge-base "${{ github.sha }}" "origin/${BASE_REF}")"
              fi
            else
              BASE="$(git merge-base "${{ github.sha }}" "origin/${BASE_REF}")"
            fi
            HEAD="${{ github.sha }}"
          else
            BASE="$(git rev-parse HEAD~1)"
            HEAD="$(git rev-parse HEAD)"
          fi

          echo "BASE=$BASE"
          echo "HEAD=$HEAD"

          # Track which detection method we use
          DETECTION_METHOD="unknown"

          # 2) Try Nx affected detection (may fail due to graph errors)
          echo "🚀 Trying Nx affected detection..."
          set +e
          AFFECTED_JSON="$(npx -y nx show projects --affected --base="$BASE" --head="$HEAD" --select=projects 2>/dev/null)"
          NX_RC=$?
          set -e

          echo "📊 Nx return code: $NX_RC"
          echo "📋 Nx affected JSON: '$AFFECTED_JSON'"

          # 3) Fallback to git diff if Nx failed or returned empty
          if [[ $NX_RC -ne 0 || -z "$AFFECTED_JSON" ]]; then
            echo "🔄 Nx failed (RC=$NX_RC) or returned empty. Falling back to git diff analysis..."
            DETECTION_METHOD="git_diff_fallback"

            CHANGED_FILES="$(git diff --name-only "$BASE" "$HEAD")"
            echo "📁 Changed files:"
            echo "$CHANGED_FILES"
            echo "📊 Total changed files: $(echo "$CHANGED_FILES" | wc -l)"

            affected=()

            echo "🔍 Checking for client-shell changes..."
            if echo "$CHANGED_FILES" | grep -q '^apps/clients/client-shell/'; then
              echo "✅ Found client-shell app changes"
              affected+=("client-shell")
            else
              echo "❌ No client-shell app changes found"
            fi

            # Check all client_* applications
            echo "🔍 Checking for client_* app changes..."
            if [ -d "apps/clients" ]; then
              for client_app in $(find apps/clients -maxdepth 1 -type d -name "client_*" 2>/dev/null -exec basename {} \;); do
                if echo "$CHANGED_FILES" | grep -q "^apps/clients/$client_app/"; then
                  echo "✅ Found $client_app app changes"
                  affected+=("$client_app")
                else
                  echo "❌ No $client_app app changes found"
                fi
              done
            fi

            # Simple heuristic for common libs
            echo "🔍 Checking for client-shell lib changes..."
            if echo "$CHANGED_FILES" | grep -q '^libs/client-shell/'; then
              echo "✅ Found client-shell lib changes"
              [[ " ${affected[*]} " =~ " client-shell " ]] || affected+=("client-shell")
            else
              echo "❌ No client-shell lib changes found"
            fi

            echo "🔍 Checking for general lib changes..."
            if echo "$CHANGED_FILES" | grep -q '^libs/'; then
              echo "✅ Found general lib changes - affecting all clients"
              # If any libs changed, consider all clients affected
              [[ " ${affected[*]} " =~ " client-shell " ]] || affected+=("client-shell")

              # Add all client_* apps when common libs change (except client-shell, already added above)
              if [ -d "apps/clients" ]; then
                for client_app in $(find apps/clients -maxdepth 1 -type d -name "client_*" 2>/dev/null -exec basename {} \;); do
                  if [[ "$client_app" != "client-shell" ]]; then
                    [[ " ${affected[*]} " =~ " $client_app " ]] || affected+=("$client_app")
                  fi
                done
              fi
            else
              echo "❌ No general lib changes found"
            fi

            echo "📋 Affected apps array: ${affected[*]}"

            # Create compact JSON string
            if [[ ${#affected[@]} -gt 0 ]]; then
              AFFECTED_JSON="$(printf '%s\n' "${affected[@]}" | jq -Rs 'split("\n") | map(select(length > 0))')"
            else
              AFFECTED_JSON='[]'
            fi
          else
            echo "✅ Nx detection successful!"
            DETECTION_METHOD="nx"

            # Convert Nx output to JSON array if it's not already JSON
            if ! echo "$AFFECTED_JSON" | jq empty 2>/dev/null; then
              echo "🔄 Converting Nx output to JSON array..."
              # Nx may return project list separated by spaces or newlines
              AFFECTED_JSON="$(echo "$AFFECTED_JSON" | tr ' ' '\n' | grep -v '^$' | jq -Rs 'split("\n") | map(select(length > 0))' 2>/dev/null || echo '[]')"
            fi
          fi

          echo "📋 Final Affected (JSON): $AFFECTED_JSON"
          echo "🔍 Detection method: $DETECTION_METHOD"

          # 4) Additional flags (example: server changes)
          HAS_SERVER_CHANGES=false
          if git diff --name-only "$BASE" "$HEAD" | grep -q '^be-'; then
            HAS_SERVER_CHANGES=true
          fi

          # 5) Determine remotes (microfrontends) - only client_* apps, excluding client-shell and e2e
          REMOTES_JSON='[]'
          REMOTES_ARRAY=()

          # Extract only client_* apps from affected apps, excluding client-shell and e2e
          for app in $(echo "$AFFECTED_JSON" | jq -r '.[]' 2>/dev/null); do
            if [[ "$app" =~ ^client_.* ]] && [[ "$app" != "client-shell" ]] && [[ ! "$app" =~ -e2e$ ]]; then
              REMOTES_ARRAY+=("$app")
            fi
          done

          # Create JSON array from remotes
          if [[ ${#REMOTES_ARRAY[@]} -gt 0 ]]; then
            REMOTES_JSON="$(printf '%s\n' "${REMOTES_ARRAY[@]}" | jq -Rs 'split("\n") | map(select(length > 0))')"
          fi

          # 6) Write outputs (multiline format is safer)
          {
            echo "affected_apps<<EOF"
            echo "$AFFECTED_JSON"
            echo "EOF"
            echo "remotes<<EOF"
            echo "$REMOTES_JSON"
            echo "EOF"
            echo "has_server_changes=$HAS_SERVER_CHANGES"
            echo "detection_method=$DETECTION_METHOD"
          } >> "$GITHUB_OUTPUT"

      - name: Restore configuration files
        if: always()
        run: |
          echo "Restoring original configuration files..."

          # Restore all .original files
          find . -name "*.original" -type f | while read -r original; do
            target="${original%.original}"
            echo "Restoring $target"
            mv "$original" "$target"
          done

          # Remove temporary JS files
          find . -name "module-federation.config.js" -type f | while read -r jsfile; do
            if [ -f "${jsfile%.js}.ts" ]; then
              echo "Removing temporary $jsfile"
              rm "$jsfile"
            fi
          done

          find . -name "webpack.config.js" -type f | while read -r jsfile; do
            if [ -f "${jsfile%.js}.ts" ]; then
              echo "Removing temporary $jsfile"
              rm "$jsfile"
            fi
          done

          echo "✅ All original files restored"

      - name: Debug outputs
        run: |
          echo "=== DEBUG OUTPUTS ==="
          APPS_OUTPUT='${{ steps.detect.outputs.affected_apps }}'
          REMOTES_OUTPUT='${{ steps.detect.outputs.remotes }}'
          echo "Apps output: '$APPS_OUTPUT'"
          echo "Remotes output: '$REMOTES_OUTPUT'"
          echo "Apps length: ${#APPS_OUTPUT}"
          echo "Remotes length: ${#REMOTES_OUTPUT}"
          echo "=== END DEBUG ==="

      - name: Check for server changes
        id: check-server
        run: |
          echo "Checking affected apps: ${{ steps.detect.outputs.affected_apps }}"

          # Check only server applications
          if echo '${{ steps.detect.outputs.affected_apps }}' | jq -e '.[] | select(. == "client-shell" or . == "be-vendure")' > /dev/null 2>&1; then
            echo "Server applications are affected"
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "No server applications affected"
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Check individual apps
        id: check-apps
        run: |
          # Check each application separately
          if echo '${{ steps.detect.outputs.affected_apps }}' | jq -e '.[] | select(. == "client-shell")' > /dev/null 2>&1; then
            echo "client-shell-affected=true" >> $GITHUB_OUTPUT
          else
            echo "client-shell-affected=false" >> $GITHUB_OUTPUT
          fi

          if echo '${{ steps.detect.outputs.affected_apps }}' | jq -e '.[] | select(. == "be-vendure")' > /dev/null 2>&1; then
            echo "be-vendure-affected=true" >> $GITHUB_OUTPUT
          else
            echo "be-vendure-affected=false" >> $GITHUB_OUTPUT
          fi

      - name: Save detection results
        run: |
          # Get values from previous steps
          APPS_JSON='${{ steps.detect.outputs.affected_apps }}'
          REMOTES_JSON='${{ steps.detect.outputs.remotes }}'
          HAS_SERVER_CHANGES='${{ steps.check-server.outputs.has-changes }}'
          CLIENT_SHELL_AFFECTED='${{ steps.check-apps.outputs.client-shell-affected }}'
          BE_VENDURE_AFFECTED='${{ steps.check-apps.outputs.be-vendure-affected }}'
          DETECTION_METHOD='${{ steps.detect.outputs.detection_method }}'

          # Validate and fix JSON if needed
          [[ -z "$APPS_JSON" || "$APPS_JSON" == "null" ]] && APPS_JSON='[]'
          [[ -z "$REMOTES_JSON" || "$REMOTES_JSON" == "null" ]] && REMOTES_JSON='[]'
          [[ -z "$DETECTION_METHOD" || "$DETECTION_METHOD" == "null" ]] && DETECTION_METHOD='unknown'

          # Validate JSON arrays
          echo "$APPS_JSON" | jq empty 2>/dev/null || APPS_JSON='[]'
          echo "$REMOTES_JSON" | jq empty 2>/dev/null || REMOTES_JSON='[]'

          # Debug variables before creating JSON
          echo "=== DEBUG VARIABLES ==="
          echo "APPS_JSON: '$APPS_JSON'"
          echo "REMOTES_JSON: '$REMOTES_JSON'"
          echo "HAS_SERVER_CHANGES: '$HAS_SERVER_CHANGES'"
          echo "CLIENT_SHELL_AFFECTED: '$CLIENT_SHELL_AFFECTED'"
          echo "BE_VENDURE_AFFECTED: '$BE_VENDURE_AFFECTED'"
          echo "DETECTION_METHOD: '$DETECTION_METHOD'"
          echo "========================"

          # Create JSON using jq for safety - pass PR title directly as arg
          jq -n \
            --arg pr_number "${{ github.event.pull_request.number }}" \
            --arg pr_title "${{ github.event.pull_request.title }}" \
            --arg pr_url "${{ github.event.pull_request.html_url }}" \
            --arg base_sha "${{ github.event.pull_request.base.sha }}" \
            --arg head_sha "${{ github.event.pull_request.head.sha }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --argjson affected_apps "$APPS_JSON" \
            --argjson affected_remotes "$REMOTES_JSON" \
            --arg has_server_changes "$HAS_SERVER_CHANGES" \
            --arg client_shell_affected "$CLIENT_SHELL_AFFECTED" \
            --arg be_vendure_affected "$BE_VENDURE_AFFECTED" \
            --arg detection_method "$DETECTION_METHOD" \
            '{
              pr_number: ($pr_number | tonumber),
              pr_title: $pr_title,
              pr_url: $pr_url,
              base_sha: $base_sha,
              head_sha: $head_sha,
              timestamp: $timestamp,
              affected_apps: $affected_apps,
              affected_remotes: $affected_remotes,
              has_server_changes: ($has_server_changes == "true"),
              client_shell_affected: ($client_shell_affected == "true"),
              be_vendure_affected: ($be_vendure_affected == "true"),
              detection_method: $detection_method
            }' > detection-results.json

          echo "Detection results:"
          if jq empty detection-results.json 2>/dev/null; then
            echo "✅ Valid JSON created"
            jq '.' detection-results.json
          else
            echo "❌ Invalid JSON created, showing raw content:"
            cat detection-results.json
            exit 1
          fi

      - name: Upload detection results
        run: |
          if [ ! -f "detection-results.json" ]; then
            echo "❌ detection-results.json not found!"
            ls -la
            exit 1
          fi
          
          echo "✅ detection-results.json exists, size: $(wc -c < detection-results.json) bytes"
          echo "📄 File content preview:"
          head -20 detection-results.json
          
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: detection-results-pr-${{ github.event.pull_request.number }}
          path: detection-results.json
          retention-days: 7

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let results;
            
            try {
              const rawData = fs.readFileSync('detection-results.json', 'utf8');
              console.log('Raw JSON data:', rawData);
              results = JSON.parse(rawData);
            } catch (error) {
              console.error('JSON parsing error:', error);
              console.error('Raw file content:', fs.readFileSync('detection-results.json', 'utf8'));
              throw error;
            }

            const affectedApps = results.affected_apps.length > 0
              ? results.affected_apps.map(app => `- ${app}`).join('\n')
              : 'No applications affected';

            const methodBadge = results.detection_method === 'git_diff_fallback'
              ? '⚠️ Fallback method used'
              : '✅ NX detection';

            const comment = `## 🔍 Change Detection Results

            ${methodBadge}

            **Affected Applications:**
            ${affectedApps}

            **Server Changes:** ${results.has_server_changes ? '✅ Yes' : '❌ No'}
            **Remote Apps:** ${results.affected_remotes.length} affected

            ---
            *This detection result has been saved and can be used for manual deployment.*
            *Artifact: \`detection-results-pr-${{ github.event.pull_request.number }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
